<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PNG Extraction Proof</title>
    <style>
      body {
        font-family: monospace;
        background: #1a1a1a;
        color: #00ff00;
        padding: 20px;
      }
      .result {
        background: #000;
        padding: 15px;
        margin: 10px 0;
        border-radius: 4px;
        border-left: 4px solid #00ff00;
      }
      .error {
        border-left-color: #ff4444;
        color: #ff4444;
      }
      button {
        background: #333;
        color: #00ff00;
        border: 1px solid #555;
        padding: 10px 20px;
        margin: 5px;
        border-radius: 4px;
        cursor: pointer;
      }
      button:hover {
        background: #444;
      }
    </style>
  </head>
  <body>
    <h1>ğŸ” PNG Metadata Extraction Proof</h1>
    <p>
      Demonstrating that I can extract real PNG metadata using the existing
      extractor:
    </p>

    <button onclick="extractABC()">Extract ABC Metadata</button>
    <button onclick="extractCAKE()">Extract CAKE Metadata</button>
    <button onclick="extractA()">Extract A Metadata</button>
    <button onclick="extractAll()">Extract All</button>

    <div id="results"></div>

    <script type="module">
      // Import the PNG metadata extractor
      import { PngMetadataExtractor } from "/src/lib/utils/png-metadata-extractor.js";

      const resultsDiv = document.getElementById("results");

      function addResult(content, isError = false) {
        const div = document.createElement("div");
        div.className = isError ? "result error" : "result";
        div.innerHTML = content;
        resultsDiv.appendChild(div);
      }

      async function extractSequence(sequenceName) {
        try {
          addResult(
            `ğŸ” Extracting ${sequenceName} using PngMetadataExtractor...`
          );

          // Use the existing PNG metadata extractor
          const metadata =
            await PngMetadataExtractor.extractSequenceMetadata(sequenceName);

          if (metadata && metadata.length > 0) {
            const firstStep = metadata[0];
            // Fix beat counting: exclude metadata (index 0) and start position (has sequence_start_position)
            const realBeats = metadata
              .slice(1)
              .filter((step) => step.letter && !step.sequence_start_position);

            let result = `âœ… <strong>${sequenceName} Real PNG Metadata:</strong><br>`;
            result += `&nbsp;&nbsp;Author: "${firstStep.author}"<br>`;
            result += `&nbsp;&nbsp;Level: ${firstStep.level}<br>`;
            result += `&nbsp;&nbsp;Grid Mode: ${firstStep.gridMode}<br>`;
            result += `&nbsp;&nbsp;Is Circular: ${firstStep.isCircular}<br>`;
            result += `&nbsp;&nbsp;Prop Type: ${firstStep.propType}<br>`;
            result += `&nbsp;&nbsp;Real Beat Count: ${realBeats.length}<br>`;
            result += `&nbsp;&nbsp;Total Steps: ${metadata.length}<br>`;

            // Show first few beats
            result += `&nbsp;&nbsp;Beat Structure:<br>`;
            realBeats.slice(0, 3).forEach((step, index) => {
              const blueMotion = step.blueAttributes?.motionType || "unknown";
              const redMotion = step.redAttributes?.motionType || "unknown";
              const beatNumber = step.beat || index + 1;
              result += `&nbsp;&nbsp;&nbsp;&nbsp;Beat ${beatNumber} (${step.letter}): blue=${blueMotion}, red=${redMotion}<br>`;
            });

            addResult(result);

            return {
              sequence: sequenceName,
              author: firstStep.author,
              level: firstStep.level,
              gridMode: firstStep.gridMode,
              isCircular: firstStep.isCircular,
              propType: firstStep.propType,
              realBeatCount: realBeats.length,
              totalSteps: metadata.length,
            };
          } else {
            addResult(`âŒ No metadata found for ${sequenceName}`, true);
            return null;
          }
        } catch (error) {
          addResult(
            `âŒ Failed to extract ${sequenceName}: ${error.message}`,
            true
          );
          return null;
        }
      }

      // Make functions available globally
      window.extractABC = () => extractSequence("ABC");
      window.extractCAKE = () => extractSequence("CAKE");
      window.extractA = () => extractSequence("A");

      window.extractAll = async () => {
        addResult("ğŸš€ <strong>Starting Full Extraction Test...</strong>");

        const sequences = ["ABC", "CAKE", "A"];
        const results = [];

        for (const seq of sequences) {
          const result = await extractSequence(seq);
          if (result) results.push(result);
          // Small delay between extractions
          await new Promise((resolve) => setTimeout(resolve, 200));
        }

        if (results.length > 0) {
          const uniqueAuthors = [...new Set(results.map((r) => r.author))];
          const levels = results
            .map((r) => r.level)
            .filter((l) => l !== undefined);
          const gridModes = [...new Set(results.map((r) => r.gridMode))];
          const beatCounts = results.map((r) => r.realBeatCount);

          let summary = `ğŸ¯ <strong>EXTRACTION PROOF COMPLETE!</strong><br>`;
          summary += `&nbsp;&nbsp;âœ… Successfully extracted ${results.length} sequences<br>`;
          summary += `&nbsp;&nbsp;ğŸ“ Real Authors: ${uniqueAuthors.join(", ")}<br>`;
          summary += `&nbsp;&nbsp;ğŸ“Š Levels: ${Math.min(...levels)} - ${Math.max(...levels)}<br>`;
          summary += `&nbsp;&nbsp;ğŸ”² Grid Modes: ${gridModes.join(", ")}<br>`;
          summary += `&nbsp;&nbsp;ğŸµ Beat Counts: ${Math.min(...beatCounts)} - ${Math.max(...beatCounts)}<br>`;
          summary += `<br><strong>ğŸš€ READY FOR PHASE 3 IMPLEMENTATION!</strong>`;

          addResult(summary);
        }
      };

      // Auto-run ABC extraction as proof
      setTimeout(() => {
        addResult("ğŸ”§ Page loaded. Auto-extracting ABC as proof...");
        extractSequence("ABC");
      }, 1000);
    </script>
  </body>
</html>
