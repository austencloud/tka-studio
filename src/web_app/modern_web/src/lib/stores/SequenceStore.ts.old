/**
 * Sequence Store - Reactive state management for sequences
 * 
 * Uses Svelte 5 runes for clean, reactive state management.
 * Integrates with the service layer for data operations.
 */

import type { SequenceData, BeatData } from '@tka/schemas';
import type { 
	ISequenceService, 
	SequenceCreateRequest,
	GenerationOptions 
} from '$services/interfaces';

export class SequenceStore {
	// Core state using runes
	private _currentSequence = $state<SequenceData | null>(null);
	private _sequences = $state<SequenceData[]>([]);
	private _isLoading = $state(false);
	private _error = $state<string | null>(null);

	// Selection state
	private _selectedBeatIndex = $state<number | null>(null);
	private _selectedSequenceId = $state<string | null>(null);

	// UI state
	private _showBeatNumbers = $state(true);
	private _gridMode = $state<'diamond' | 'box'>('diamond');

	constructor(private sequenceService: ISequenceService) {}

	// ============================================================================
	// REACTIVE GETTERS
	// ============================================================================

	get currentSequence() { 
		return this._currentSequence; 
	}

	get sequences() { 
		return this._sequences; 
	}

	get isLoading() { 
		return this._isLoading; 
	}

	get error() { 
		return this._error; 
	}

	get selectedBeatIndex() { 
		return this._selectedBeatIndex; 
	}

	get selectedSequenceId() { 
		return this._selectedSequenceId; 
	}

	get showBeatNumbers() { 
		return this._showBeatNumbers; 
	}

	get gridMode() { 
		return this._gridMode; 
	}

	// Computed properties
	get currentBeats(): BeatData[] {
		return this._currentSequence?.beats ?? [];
	}

	get selectedBeat(): BeatData | null {
		if (this._selectedBeatIndex === null || !this._currentSequence) {
			return null;
		}
		return this._currentSequence.beats[this._selectedBeatIndex] ?? null;
	}

	get hasUnsavedChanges(): boolean {
		// TODO: Implement change tracking
		return false;
	}

	// ============================================================================
	// SEQUENCE OPERATIONS
	// ============================================================================

	/**
	 * Create a new sequence
	 */
	async createSequence(request: SequenceCreateRequest): Promise<SequenceData> {
		this._isLoading = true;
		this._error = null;

		try {
			console.log('SequenceStore: Creating sequence', request);
			
			const sequence = await this.sequenceService.createSequence(request);
			
			// Add to sequences list
			this._sequences.push(sequence);
			
			// Set as current sequence
			this._currentSequence = sequence;
			this._selectedSequenceId = sequence.id;
			
			console.log('SequenceStore: Sequence created successfully');
			return sequence;
		} catch (error) {
			const errorMessage = error instanceof Error ? error.message : 'Unknown error';
			this._error = errorMessage;
			console.error('SequenceStore: Failed to create sequence:', error);
			throw error;
		} finally {
			this._isLoading = false;
		}
	}

	/**
	 * Load all sequences
	 */
	async loadSequences(): Promise<void> {
		this._isLoading = true;
		this._error = null;

		try {
			console.log('SequenceStore: Loading sequences');
			
			const sequences = await this.sequenceService.getAllSequences();
			this._sequences = sequences;
			
			console.log(`SequenceStore: Loaded ${sequences.length} sequences`);
		} catch (error) {
			const errorMessage = error instanceof Error ? error.message : 'Unknown error';
			this._error = errorMessage;
			console.error('SequenceStore: Failed to load sequences:', error);
		} finally {
			this._isLoading = false;
		}
	}

	/**
	 * Select a sequence as current
	 */
	async selectSequence(sequenceId: string): Promise<void> {
		this._isLoading = true;
		this._error = null;

		try {
			console.log('SequenceStore: Selecting sequence', sequenceId);
			
			const sequence = await this.sequenceService.getSequence(sequenceId);
			
			if (sequence) {
				this._currentSequence = sequence;
				this._selectedSequenceId = sequenceId;
				this._selectedBeatIndex = null; // Reset beat selection
			} else {
				throw new Error(`Sequence ${sequenceId} not found`);
			}
		} catch (error) {
			const errorMessage = error instanceof Error ? error.message : 'Unknown error';
			this._error = errorMessage;
			console.error('SequenceStore: Failed to select sequence:', error);
		} finally {
			this._isLoading = false;
		}
	}

	/**
	 * Delete a sequence
	 */
	async deleteSequence(sequenceId: string): Promise<void> {
		this._isLoading = true;
		this._error = null;

		try {
			console.log('SequenceStore: Deleting sequence', sequenceId);
			
			await this.sequenceService.deleteSequence(sequenceId);
			
			// Remove from sequences list
			this._sequences = this._sequences.filter(s => s.id !== sequenceId);
			
			// Clear current sequence if it was deleted
			if (this._currentSequence?.id === sequenceId) {
				this._currentSequence = null;
				this._selectedSequenceId = null;
				this._selectedBeatIndex = null;
			}
			
			console.log('SequenceStore: Sequence deleted successfully');
		} catch (error) {
			const errorMessage = error instanceof Error ? error.message : 'Unknown error';
			this._error = errorMessage;
			console.error('SequenceStore: Failed to delete sequence:', error);
			throw error;
		} finally {
			this._isLoading = false;
		}
	}

	// ============================================================================
	// BEAT OPERATIONS
	// ============================================================================

	/**
	 * Update a beat in the current sequence
	 */
	async updateBeat(beatIndex: number, beatData: BeatData): Promise<void> {
		if (!this._currentSequence) {
			throw new Error('No current sequence selected');
		}

		this._isLoading = true;
		this._error = null;

		try {
			console.log('SequenceStore: Updating beat', beatIndex);
			
			await this.sequenceService.updateBeat(
				this._currentSequence.id,
				beatIndex,
				beatData
			);
			
			// Update local state
			const updatedBeats = [...this._currentSequence.beats];
			updatedBeats[beatIndex] = beatData;
			
			this._currentSequence = {
				...this._currentSequence,
				beats: updatedBeats,
				updatedAt: new Date().toISOString()
			};
			
			// Update in sequences list
			const sequenceIndex = this._sequences.findIndex(s => s.id === this._currentSequence!.id);
			if (sequenceIndex >= 0) {
				this._sequences[sequenceIndex] = this._currentSequence;
			}
			
			console.log('SequenceStore: Beat updated successfully');
		} catch (error) {
			const errorMessage = error instanceof Error ? error.message : 'Unknown error';
			this._error = errorMessage;
			console.error('SequenceStore: Failed to update beat:', error);
			throw error;
		} finally {
			this._isLoading = false;
		}
	}

	/**
	 * Select a beat
	 */
	selectBeat(beatIndex: number | null): void {
		this._selectedBeatIndex = beatIndex;
		console.log('SequenceStore: Beat selected', beatIndex);
	}

	// ============================================================================
	// UI STATE MANAGEMENT
	// ============================================================================

	/**
	 * Toggle beat numbers visibility
	 */
	toggleBeatNumbers(): void {
		this._showBeatNumbers = !this._showBeatNumbers;
	}

	/**
	 * Set grid mode
	 */
	setGridMode(mode: 'diamond' | 'box'): void {
		this._gridMode = mode;
	}

	/**
	 * Clear error state
	 */
	clearError(): void {
		this._error = null;
	}

	/**
	 * Clear current selection
	 */
	clearSelection(): void {
		this._currentSequence = null;
		this._selectedSequenceId = null;
		this._selectedBeatIndex = null;
	}

	// ============================================================================
	// UTILITY METHODS
	// ============================================================================

	/**
	 * Get sequence by ID from loaded sequences
	 */
	getSequenceById(id: string): SequenceData | null {
		return this._sequences.find(s => s.id === id) ?? null;
	}

	/**
	 * Check if a sequence is currently selected
	 */
	isSequenceSelected(id: string): boolean {
		return this._selectedSequenceId === id;
	}

	/**
	 * Get store state for debugging
	 */
	getState() {
		return {
			currentSequence: this._currentSequence,
			sequences: this._sequences,
			isLoading: this._isLoading,
			error: this._error,
			selectedBeatIndex: this._selectedBeatIndex,
			selectedSequenceId: this._selectedSequenceId,
		};
	}
}
