"""
Regenerate Sequence Card Images Script

This script uses the modern image exporter to regenerate all sequence card images
with complete information, replacing the legacy exported images.
"""

from __future__ import annotations

from datetime import datetime
import logging
from pathlib import Path
import sys


# Add the modern src directory to the path
modern_src_path = Path(__file__).parent.parent / "src"
sys.path.insert(0, str(modern_src_path))

from PyQt6.QtWidgets import QApplication

from desktop.modern.core.dependency_injection.di_container import DIContainer
from desktop.modern.core.dependency_injection.image_export_service_registration import (
    register_image_export_services,
)
from desktop.modern.core.interfaces.image_export_services import (
    ExportProgress,
    IImageExportService,
    ImageExportOptions,
)


# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("sequence_image_regeneration.log"),
        logging.StreamHandler(sys.stdout),
    ],
)

logger = logging.getLogger(__name__)


class SequenceImageRegenerator:
    """
    Handles the regeneration of all sequence card images using the modern exporter.
    """

    def __init__(self):
        self.app = None
        self.container = None
        self.export_service = None
        self.stats = {
            "start_time": None,
            "end_time": None,
            "total_files": 0,
            "successful": 0,
            "failed": 0,
            "skipped": 0,
        }

    def initialize(self) -> bool:
        """Initialize the regeneration environment."""
        try:
            logger.info("Initializing sequence image regenerator...")

            # Create QApplication if needed
            if not QApplication.instance():
                self.app = QApplication([])
            else:
                self.app = QApplication.instance()

            # Set up dependency injection
            self.container = DIContainer()
            register_image_export_services(self.container)

            # Get the export service
            self.export_service = self.container.resolve(IImageExportService)

            logger.info("Regenerator initialized successfully")
            return True

        except Exception as e:
            logger.error(f"Failed to initialize regenerator: {e}", exc_info=True)
            return False

    def get_default_paths(self) -> tuple[Path, Path]:
        """Get the default source and export paths."""
        # Default paths based on TKA structure
        tka_root = Path(__file__).parent.parent.parent.parent.parent

        # Source: dictionary data
        source_path = tka_root / "data" / "dictionary"

        # Export: sequence card images
        export_path = tka_root / "images" / "sequence_card_images"

        return source_path, export_path

    def create_export_options(self) -> ImageExportOptions:
        """Create export options with all visual elements enabled."""
        return ImageExportOptions(
            # Enable all visual elements for complete information
            add_word=True,
            add_user_info=True,
            add_difficulty_level=True,
            add_date=True,
            add_note=True,
            add_beat_numbers=True,
            add_reversal_symbols=True,
            include_start_position=True,
            combined_grids=False,
            # User information
            user_name="TKA Modern System",
            export_date=datetime.now().strftime("%m-%d-%Y"),
            notes="Generated by Modern TKA Image Exporter",
            # High quality settings
            png_compression=1,  # Maximum quality
            high_quality=True,
        )

    def progress_callback(self, progress: ExportProgress) -> None:
        """Handle progress updates during export."""
        percentage = progress.percentage
        logger.info(
            f"Progress: {percentage:.1f}% ({progress.current}/{progress.total}) - {progress.message}"
        )

        # Update console with progress bar
        if progress.total > 0:
            bar_length = 50
            filled_length = int(bar_length * progress.current // progress.total)
            bar = "█" * filled_length + "-" * (bar_length - filled_length)
            print(f"\r|{bar}| {percentage:.1f}% Complete", end="", flush=True)

    def regenerate_all_images(
        self,
        source_path: Path | None = None,
        export_path: Path | None = None,
        force_regenerate: bool = False,
    ) -> bool:
        """
        Regenerate all sequence card images.

        Args:
            source_path: Path to source dictionary data (optional)
            export_path: Path to export directory (optional)
            force_regenerate: If True, regenerate all images even if they exist

        Returns:
            True if regeneration was successful, False otherwise
        """
        try:
            self.stats["start_time"] = datetime.now()

            # Use default paths if not provided
            if source_path is None or export_path is None:
                default_source, default_export = self.get_default_paths()
                source_path = source_path or default_source
                export_path = export_path or default_export

            logger.info("Starting image regeneration...")
            logger.info(f"Source path: {source_path}")
            logger.info(f"Export path: {export_path}")
            logger.info(f"Force regenerate: {force_regenerate}")

            # Verify source path exists
            if not source_path.exists():
                logger.error(f"Source path does not exist: {source_path}")
                return False

            # Create export directory if needed
            export_path.mkdir(parents=True, exist_ok=True)

            # Create export options
            options = self.create_export_options()

            # If force regenerate, we need to modify the service behavior
            if force_regenerate:
                logger.info("Force regeneration enabled - all images will be recreated")
                # This would require modifying the service to ignore file timestamps
                # For now, we'll delete existing images to force regeneration
                self._clear_existing_images(export_path)

            # Run the export
            logger.info("Starting batch export...")
            results = self.export_service.export_all_sequences(
                source_path, export_path, options, self.progress_callback
            )

            # Update statistics
            self.stats.update(
                {
                    "end_time": datetime.now(),
                    "total_files": results.get("total_files", 0),
                    "successful": results.get("successful", 0),
                    "failed": results.get("failed", 0),
                    "skipped": results.get("skipped", 0),
                }
            )

            # Log results
            self._log_results(results)

            return results.get("success", False)

        except Exception as e:
            logger.error(f"Error during image regeneration: {e}", exc_info=True)
            return False

    def _clear_existing_images(self, export_path: Path) -> None:
        """Clear existing images to force regeneration."""
        logger.info("Clearing existing images for force regeneration...")

        try:
            for word_dir in export_path.iterdir():
                if word_dir.is_dir():
                    for image_file in word_dir.glob("*.png"):
                        image_file.unlink()
                        logger.debug(f"Deleted existing image: {image_file}")
        except Exception as e:
            logger.warning(f"Error clearing existing images: {e}")

    def _log_results(self, results: dict) -> None:
        """Log the final results of the regeneration process."""
        print()  # New line after progress bar

        duration = self.stats["end_time"] - self.stats["start_time"]

        logger.info("=" * 60)
        logger.info("SEQUENCE IMAGE REGENERATION COMPLETE")
        logger.info("=" * 60)
        logger.info(f"Duration: {duration}")
        logger.info(f"Total files processed: {self.stats['total_files']}")
        logger.info(f"Successfully exported: {self.stats['successful']}")
        logger.info(f"Failed: {self.stats['failed']}")
        logger.info(f"Skipped (up-to-date): {self.stats['skipped']}")

        if self.stats["total_files"] > 0:
            success_rate = (self.stats["successful"] / self.stats["total_files"]) * 100
            logger.info(f"Success rate: {success_rate:.1f}%")

        if results.get("success", False):
            logger.info("✅ Regeneration completed successfully!")
        else:
            logger.error("❌ Regeneration completed with errors")

        logger.info("=" * 60)


def main():
    """Main entry point for the regeneration script."""
    import argparse

    parser = argparse.ArgumentParser(description="Regenerate TKA sequence card images")
    parser.add_argument(
        "--source", type=Path, help="Source directory containing sequence data"
    )
    parser.add_argument(
        "--export", type=Path, help="Export directory for generated images"
    )
    parser.add_argument(
        "--force",
        action="store_true",
        help="Force regeneration of all images (ignore timestamps)",
    )
    parser.add_argument("--verbose", action="store_true", help="Enable verbose logging")

    args = parser.parse_args()

    # Set logging level
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    # Create and run regenerator
    regenerator = SequenceImageRegenerator()

    if not regenerator.initialize():
        logger.error("Failed to initialize regenerator")
        sys.exit(1)

    success = regenerator.regenerate_all_images(
        source_path=args.source, export_path=args.export, force_regenerate=args.force
    )

    if success:
        logger.info("Image regeneration completed successfully")
        sys.exit(0)
    else:
        logger.error("Image regeneration failed")
        sys.exit(1)


if __name__ == "__main__":
    main()
