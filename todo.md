# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.# Task 4: Extract Border Management Service

## MISSION

Extract the border calculation business logic from `PictographBorderManager` in the presentation layer and create a proper `PictographBorderService`. This is a **single-component extraction** focused on border calculations and rules.

## CURRENT VIOLATION

**File**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
**Problem**: 200+ lines of border calculation business logic living in presentation layer
**Business Logic**: Border width calculations, color determination, size adjustments, border state management

## TARGET ARCHITECTURE

### New Service Location

**Create**: `src/desktop/modern/src/application/services/pictographs/border_service.py`

### Keep Presentation Manager

**Update**: `src/desktop/modern/src/presentation/components/pictograph/border_manager.py`
(Make it a thin wrapper that uses the service)

## STEP-BY-STEP EXECUTION

### STEP 1: Create Service Directory

```bash
mkdir -p src/desktop/modern/src/application/services/pictographs
touch src/desktop/modern/src/application/services/pictographs/__init__.py
```

### STEP 2: Create Pure Business Service

Create `application/services/pictographs/border_service.py`:

```python
"""
Pictograph Border Service - Pure Business Logic

Handles all border calculations, color determination, and sizing logic
without any Qt dependencies.
"""

import logging
from typing import Tuple, Dict, Optional
from domain.models import LetterType

logger = logging.getLogger(__name__)

class BorderConfiguration:
    """Configuration for border appearance and calculations."""

    def __init__(
        self,
        width_percentage: float = 0.015,
        minimum_width: int = 1,
        enabled: bool = True,
        primary_color: str = "#000000",
        secondary_color: str = "#000000"
    ):
        self.width_percentage = width_percentage
        self.minimum_width = minimum_width
        self.enabled = enabled
        self.primary_color = primary_color
        self.secondary_color = secondary_color

class BorderDimensions:
    """Border dimension calculations."""

    def __init__(self, outer_width: float, inner_width: float, adjusted_size: int):
        self.outer_width = outer_width
        self.inner_width = inner_width
        self.adjusted_size = adjusted_size

class PictographBorderService:
    """
    Pure business service for pictograph border management.

    Handles border calculations, color determination, and sizing logic
    without any Qt dependencies.
    """

    # Letter type to color mapping
    LETTER_TYPE_COLORS = {
        LetterType.TYPE1: ("#36c3ff", "#6F2DA8"),  # Cyan, Purple
        LetterType.TYPE2: ("#6F2DA8", "#6F2DA8"),  # Purple, Purple
        LetterType.TYPE3: ("#26e600", "#6F2DA8"),  # Green, Purple
        LetterType.TYPE4: ("#26e600", "#26e600"),  # Green, Green
        LetterType.TYPE5: ("#00b3ff", "#26e600"),  # Blue, Green
        LetterType.TYPE6: ("#eb7d00", "#eb7d00"),  # Orange, Orange
    }

    # Special colors
    GOLD_COLOR = "#FFD700"
    DEFAULT_COLOR = "#000000"

    def __init__(self):
        """Initialize the border service with default configuration."""
        self._config = BorderConfiguration()
        self._original_primary_color = self.DEFAULT_COLOR
        self._original_secondary_color = self.DEFAULT_COLOR

        logger.debug("Pictograph border service initialized")

    # Border Width Calculations
    def calculate_border_width(self, size: int) -> int:
        """
        Calculate border width based on size using the standard formula.

        Args:
            size: The base size to calculate border width for

        Returns:
            int: The calculated border width
        """
        calculated_width = int(size * self._config.width_percentage)
        return max(self._config.minimum_width, calculated_width)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """
        Get size adjusted for border width.

        Args:
            target_size: The target size before border adjustment

        Returns:
            int: The size adjusted for borders (minimum 50)
        """
        border_width = self.calculate_border_width(target_size)
        adjusted_size = target_size - (2 * border_width)
        return max(50, adjusted_size)  # Minimum viable size

    def calculate_floating_dimensions(self, view_width: int) -> BorderDimensions:
        """
        Calculate floating-point border dimensions for precise drawing.

        Args:
            view_width: Width of the view for calculations

        Returns:
            BorderDimensions: Calculated dimensions for drawing
        """
        # Legacy formula: max(1.0, view_width * 0.016)
        outer_border_width = max(1.0, view_width * 0.016)
        inner_border_width = max(1.0, view_width * 0.016)
        adjusted_size = int(view_width - (2 * outer_border_width))

        return BorderDimensions(
            outer_width=outer_border_width,
            inner_width=inner_border_width,
            adjusted_size=max(50, adjusted_size)
        )

    # Color Management
    def determine_colors_for_letter_type(self, letter_type: LetterType) -> Tuple[str, str]:
        """
        Determine border colors based on letter type.

        Args:
            letter_type: The letter type to get colors for

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return self.LETTER_TYPE_COLORS.get(
            letter_type,
            (self.DEFAULT_COLOR, self.DEFAULT_COLOR)
        )

    def apply_letter_type_colors(self, letter_type: LetterType) -> BorderConfiguration:
        """
        Apply colors for a specific letter type and return updated configuration.

        Args:
            letter_type: The letter type to apply colors for

        Returns:
            BorderConfiguration: Updated configuration with new colors
        """
        primary, secondary = self.determine_colors_for_letter_type(letter_type)

        # Store originals for reset capability
        self._original_primary_color = primary
        self._original_secondary_color = secondary

        # Update current configuration
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied colors for {letter_type}: {primary}, {secondary}")
        return self._config

    def apply_gold_colors(self) -> BorderConfiguration:
        """
        Apply gold colors (typically used for hover states).

        Returns:
            BorderConfiguration: Updated configuration with gold colors
        """
        self._config.primary_color = self.GOLD_COLOR
        self._config.secondary_color = self.GOLD_COLOR

        logger.debug("Applied gold border colors")
        return self._config

    def apply_custom_colors(self, primary: str, secondary: str) -> BorderConfiguration:
        """
        Apply custom border colors.

        Args:
            primary: Primary border color
            secondary: Secondary border color

        Returns:
            BorderConfiguration: Updated configuration with custom colors
        """
        self._config.primary_color = primary
        self._config.secondary_color = secondary

        logger.debug(f"Applied custom colors: {primary}, {secondary}")
        return self._config

    def reset_to_original_colors(self) -> BorderConfiguration:
        """
        Reset border colors to their original values.

        Returns:
            BorderConfiguration: Configuration with original colors restored
        """
        self._config.primary_color = self._original_primary_color
        self._config.secondary_color = self._original_secondary_color

        logger.debug("Reset to original border colors")
        return self._config

    # Configuration Management
    def enable_borders(self) -> BorderConfiguration:
        """
        Enable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders enabled
        """
        self._config.enabled = True
        logger.debug("Borders enabled")
        return self._config

    def disable_borders(self) -> BorderConfiguration:
        """
        Disable border rendering.

        Returns:
            BorderConfiguration: Updated configuration with borders disabled
        """
        self._config.enabled = False
        logger.debug("Borders disabled")
        return self._config

    def set_border_width_percentage(self, percentage: float) -> BorderConfiguration:
        """
        Set the border width percentage.

        Args:
            percentage: Border width as percentage of size (e.g., 0.015 = 1.5%)

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.width_percentage = max(0.0, percentage)
        logger.debug(f"Border width percentage set to: {percentage}")
        return self._config

    def set_minimum_border_width(self, width: int) -> BorderConfiguration:
        """
        Set the minimum border width.

        Args:
            width: Minimum border width in pixels

        Returns:
            BorderConfiguration: Updated configuration
        """
        self._config.minimum_width = max(0, width)
        logger.debug(f"Minimum border width set to: {width}")
        return self._config

    # State Access
    def get_current_configuration(self) -> BorderConfiguration:
        """
        Get the current border configuration.

        Returns:
            BorderConfiguration: Current configuration
        """
        return self._config

    def is_borders_enabled(self) -> bool:
        """
        Check if borders are currently enabled.

        Returns:
            bool: True if borders are enabled
        """
        return self._config.enabled

    def get_current_colors(self) -> Tuple[str, str]:
        """
        Get the current border colors.

        Returns:
            Tuple[str, str]: (primary_color, secondary_color)
        """
        return (self._config.primary_color, self._config.secondary_color)

    def get_original_colors(self) -> Tuple[str, str]:
        """
        Get the original border colors.

        Returns:
            Tuple[str, str]: (original_primary_color, original_secondary_color)
        """
        return (self._original_primary_color, self._original_secondary_color)

    # Validation and Utilities
    def validate_configuration(self) -> bool:
        """
        Validate the current configuration.

        Returns:
            bool: True if configuration is valid
        """
        if self._config.width_percentage < 0:
            return False
        if self._config.minimum_width < 0:
            return False

        # Validate color format (basic check)
        for color in [self._config.primary_color, self._config.secondary_color]:
            if not isinstance(color, str) or not color.startswith('#'):
                return False

        return True

    def get_service_summary(self) -> Dict[str, any]:
        """
        Get a summary of the service state.

        Returns:
            Dict: Service state information
        """
        return {
            "borders_enabled": self._config.enabled,
            "width_percentage": self._config.width_percentage,
            "minimum_width": self._config.minimum_width,
            "current_primary_color": self._config.primary_color,
            "current_secondary_color": self._config.secondary_color,
            "original_primary_color": self._original_primary_color,
            "original_secondary_color": self._original_secondary_color,
            "configuration_valid": self.validate_configuration(),
        }
```

### STEP 3: Update Presentation Manager

Modify `presentation/components/pictograph/border_manager.py`:

```python
"""
Pictograph Border Manager - Qt Presentation Layer

Handles Qt-specific border rendering while delegating business logic
to PictographBorderService.
"""

from typing import Tuple
from PyQt6.QtCore import Qt, QRectF
from PyQt6.QtGui import QPainter, QPen, QColor

from domain.models import LetterType
from application.services.pictographs.border_service import (
    PictographBorderService,
    BorderConfiguration,
    BorderDimensions
)

class PictographBorderManager:
    """
    Qt presentation manager for pictograph borders.

    Handles Qt-specific rendering while delegating calculations
    to PictographBorderService.
    """

    def __init__(self, border_service: PictographBorderService):
        """Initialize with border service."""
        self._border_service = border_service

    # Configuration Methods
    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_service.apply_letter_type_colors(letter_type)

    def set_gold_border(self) -> None:
        """Set border colors to gold."""
        self._border_service.apply_gold_colors()

    def reset_border_colors(self) -> None:
        """Reset border colors to their original values."""
        self._border_service.reset_to_original_colors()

    def set_custom_border_colors(self, primary: str, secondary: str) -> None:
        """Set custom border colors."""
        self._border_service.apply_custom_colors(primary, secondary)

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_service.enable_borders()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_service.disable_borders()

    def set_border_width_percentage(self, percentage: float) -> None:
        """Set the border width percentage."""
        self._border_service.set_border_width_percentage(percentage)

    def set_minimum_border_width(self, width: int) -> None:
        """Set the minimum border width."""
        self._border_service.set_minimum_border_width(width)

    # Calculation Methods (delegate to service)
    def calculate_border_width(self, size: int) -> int:
        """Calculate border width based on size."""
        return self._border_service.calculate_border_width(size)

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_service.get_border_adjusted_size(target_size)

    def get_border_dimensions(self, view_width: int) -> Tuple[float, float]:
        """Get border dimensions for drawing."""
        dimensions = self._border_service.calculate_floating_dimensions(view_width)
        return (dimensions.outer_width, dimensions.inner_width)

    # Qt Rendering Methods
    def draw_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """
        Draw borders on the viewport using Qt.

        Args:
            painter: QPainter instance for drawing
            viewport_rect: The viewport rectangle to draw borders on
            view_width: Width of the view for border calculations
        """
        config = self._border_service.get_current_configuration()

        if not config.enabled:
            return

        # Get dimensions from service
        dimensions = self._border_service.calculate_floating_dimensions(view_width)

        # Calculate half pen widths for proper positioning
        half_outer_pen = dimensions.outer_width / 2.0
        half_inner_pen = dimensions.inner_width / 2.0

        # Draw outer border
        pen = QPen()
        pen.setColor(QColor(config.primary_color))
        pen.setWidthF(dimensions.outer_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        # Convert viewport rect to QRectF
        outer_rect = QRectF(viewport_rect)
        outer_rect = outer_rect.adjusted(
            +half_outer_pen,
            +half_outer_pen,
            -half_outer_pen,
            -half_outer_pen,
        )
        painter.drawRect(outer_rect)

        # Draw inner border
        pen.setColor(QColor(config.secondary_color))
        pen.setWidthF(dimensions.inner_width)
        pen.setJoinStyle(Qt.PenJoinStyle.MiterJoin)
        painter.setPen(pen)

        inner_rect = outer_rect.adjusted(
            +half_inner_pen,
            +half_inner_pen,
            -half_inner_pen,
            -half_inner_pen,
        )
        painter.drawRect(inner_rect)

    # State Access Methods
    def is_borders_enabled(self) -> bool:
        """Check if borders are enabled."""
        return self._border_service.is_borders_enabled()

    def get_current_colors(self) -> Tuple[str, str]:
        """Get current border colors."""
        return self._border_service.get_current_colors()

class BorderedPictographMixin:
    """
    Mixin class to add border functionality to pictograph components.

    Updated to use the border service through the manager.
    """

    def __init__(self, border_service: PictographBorderService):
        self._border_manager = PictographBorderManager(border_service)

    def update_border_colors_for_letter_type(self, letter_type: LetterType) -> None:
        """Update border colors based on letter type."""
        self._border_manager.update_border_colors_for_letter_type(letter_type)
        if hasattr(self, "update"):
            self.update()  # Trigger repaint if this is a widget

    def set_gold_border(self) -> None:
        """Set border to gold color."""
        self._border_manager.set_gold_border()
        if hasattr(self, "update"):
            self.update()

    def reset_border_colors(self) -> None:
        """Reset border colors to original values."""
        self._border_manager.reset_border_colors()
        if hasattr(self, "update"):
            self.update()

    def enable_borders(self) -> None:
        """Enable border rendering."""
        self._border_manager.enable_borders()
        if hasattr(self, "update"):
            self.update()

    def disable_borders(self) -> None:
        """Disable border rendering."""
        self._border_manager.disable_borders()
        if hasattr(self, "update"):
            self.update()

    def get_border_adjusted_size(self, target_size: int) -> int:
        """Get size adjusted for border width."""
        return self._border_manager.get_border_adjusted_size(target_size)

    def calculate_border_width(self, size: int) -> int:
        """Calculate border width for given size."""
        return self._border_manager.calculate_border_width(size)

    def draw_pictograph_borders(self, painter: QPainter, viewport_rect, view_width: int) -> None:
        """Draw borders on the pictograph viewport."""
        self._border_manager.draw_borders(painter, viewport_rect, view_width)
```

### STEP 4: Update Service Registration

Add to `application/services/core/service_registration_manager.py`:

```python
def register_pictograph_services(self, container):
    """Register pictograph services."""
    from application.services.pictographs.border_service import PictographBorderService

    container.register_singleton(PictographBorderService)
    logger.info("Pictograph services registered")
```

### STEP 5: Update Dependency Injection

Modify pictograph components to inject the service:

**In pictograph component constructors**:

```python
def __init__(self, border_service: PictographBorderService, parent=None):
    super().__init__(parent)
    # Initialize mixin with service
    BorderedPictographMixin.__init__(self, border_service)
    # ... rest of initialization
```

### STEP 6: Update Import References

Update any direct imports of the border manager:

**Search for**: `from presentation.components.pictograph.border_manager import`
**Update to also import**: `from application.services.pictographs.border_service import PictographBorderService`

## VALIDATION CHECKLIST

### ✅ Service Creation

- [ ] Pure business service for border calculations
- [ ] All calculation logic moved from presentation
- [ ] Service has no Qt dependencies
- [ ] Comprehensive border configuration management

### ✅ Presentation Update

- [ ] Border manager updated to use service
- [ ] Qt-specific rendering preserved
- [ ] Business logic delegated to service
- [ ] Mixin pattern maintained for compatibility

### ✅ Dependency Injection

- [ ] Service registered in DI container
- [ ] Pictograph components updated to receive service
- [ ] Proper service injection implemented

### ✅ Functionality Verification

- [ ] Border rendering works identically
- [ ] Color changes function correctly
- [ ] Size calculations are accurate
- [ ] All border features preserved

## SUCCESS CRITERIA

1. **Zero border business logic in presentation layer**
2. **PictographBorderService is independently testable**
3. **All existing border functionality preserved**
4. **Clean separation between calculations and rendering**
5. **Improved border configuration management**

---

**SCOPE**: This task focuses ONLY on the pictograph border management. No other components should be modified. Complete this task before moving to the next extraction.
