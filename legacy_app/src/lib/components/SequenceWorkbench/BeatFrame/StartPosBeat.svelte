<!-- src/lib/components/SequenceWorkbench/BeatFrame/StartPosBeat.svelte -->
<script lang="ts">
	import { onMount } from 'svelte';
	import Beat from './Beat.svelte';
	import type { BeatData } from './BeatData';
	import { defaultPictographData } from '$lib/components/Pictograph/utils/defaultPictographData';
	import { selectedStartPos } from '$lib/stores/sequence/selectionStore';
	import { pictographContainer } from '$lib/state/stores/pictograph/pictographContainer';
	import type { PictographData } from '$lib/types/PictographData';
	import StyledBorderOverlay from '$lib/components/Pictograph/components/StyledBorderOverlay.svelte';
	import { sequenceContainer } from '$lib/state/stores/sequence/SequenceContainer';
	import hapticFeedbackService from '$lib/services/HapticFeedbackService';

	// Props using Svelte 5 runes
	const props = $props<{
		beatData: BeatData;
		onClick: () => void;
	}>();

	// Local state
	let beatData = $state(props.beatData);
	let showBorder = $state(false);
	let pictographData = $state<PictographData>(defaultPictographData);
	let isSelected = $state(false);

	// Update isSelected when the selection changes
	// Use a more reactive approach with a manual subscription for immediate updates
	$effect(() => {
		// Create a subscription to the sequenceContainer state
		const unsubscribe = sequenceContainer.subscribe((state) => {
			// Update the selection state immediately when it changes
			isSelected = state.selectedBeatIds.includes('start-position');
		});

		// Clean up the subscription when the component is destroyed or the effect is re-run
		return unsubscribe;
	});

	// Initialize pictographData from props
	$effect(() => {
		if (props.beatData && props.beatData.pictographData) {
			pictographData = safeCopyPictographData(props.beatData.pictographData);
		}
	});

	// Helper function to safely copy pictograph data without circular references
	// Also ensures the data is valid for a start position (start and end locations must be the same)
	function safeCopyPictographData(data: PictographData): PictographData {
		// Create a new object with only the properties we need
		const safeCopy: PictographData = {
			letter: data.letter,
			startPos: data.startPos,
			endPos: data.endPos,
			timing: data.timing,
			direction: data.direction,
			gridMode: data.gridMode,
			grid: data.grid,
			isStartPosition: true, // Mark this as a start position

			// Copy motion data safely and ensure start/end locations are the same
			redMotionData: data.redMotionData
				? {
						id: data.redMotionData.id,
						handRotDir: data.redMotionData.handRotDir,
						color: data.redMotionData.color,
						leadState: data.redMotionData.leadState,
						motionType: 'static', // Force static for start position
						startLoc: data.redMotionData.startLoc,
						endLoc: data.redMotionData.startLoc, // Force end location to match start location
						startOri: data.redMotionData.startOri,
						endOri: data.redMotionData.startOri, // Force end orientation to match start orientation
						propRotDir: data.redMotionData.propRotDir,
						turns: 0, // Force no turns for start position
						prefloatMotionType: null,
						prefloatPropRotDir: null
					}
				: null,

			blueMotionData: data.blueMotionData
				? {
						id: data.blueMotionData.id,
						handRotDir: data.blueMotionData.handRotDir,
						color: data.blueMotionData.color,
						leadState: data.blueMotionData.leadState,
						motionType: 'static', // Force static for start position
						startLoc: data.blueMotionData.startLoc,
						endLoc: data.blueMotionData.startLoc, // Force end location to match start location
						startOri: data.blueMotionData.startOri,
						endOri: data.blueMotionData.startOri, // Force end orientation to match start orientation
						propRotDir: data.blueMotionData.propRotDir,
						turns: 0, // Force no turns for start position
						prefloatMotionType: null,
						prefloatPropRotDir: null
					}
				: null,

			// These will be generated by the Pictograph component
			redPropData: null,
			bluePropData: null,
			redArrowData: null,
			blueArrowData: null,
			gridData: null,

			// Copy arrays safely
			motions: [],
			redMotion: null,
			blueMotion: null,
			props: []
		};

		// Log that we're creating a start position

		return safeCopy;
	}

	// Flag to prevent circular updates
	let isUpdatingFromStartPos = false;

	// Update pictographData when beatData changes, but only if not already updating from selectedStartPos
	$effect(() => {
		if (!isUpdatingFromStartPos && beatData && beatData.pictographData) {
			pictographData = safeCopyPictographData(beatData.pictographData);
		}
	});

	// Subscribe to the selectedStartPos store
	onMount(() => {
		const unsubscribe = selectedStartPos.subscribe((startPos) => {
			// Set flag to prevent circular updates
			isUpdatingFromStartPos = true;

			try {
				if (startPos) {
					// Create a deep copy to avoid reference issues
					const startPosCopy = JSON.parse(JSON.stringify(startPos));

					// Update the local pictograph data
					pictographData = safeCopyPictographData(startPosCopy);

					// Also update the pictographContainer
					pictographContainer.setData(pictographData);

					// Save to localStorage directly to ensure it's available during hot reloads
					try {
						localStorage.setItem('start_position', JSON.stringify(pictographData));
					} catch (error) {
						console.error('Failed to save start position to localStorage:', error);
					}

					// Update the beat data
					beatData = {
						...beatData,
						pictographData: startPosCopy,
						filled: true
					};
				} else {
					// If no start position is set, use default data
					pictographData = defaultPictographData;

					// Also update the pictographContainer
					pictographContainer.setData(defaultPictographData);

					// Update the beat data
					beatData = {
						...beatData,
						pictographData: defaultPictographData,
						filled: false
					};
				}
			} finally {
				// Reset flag after updates are complete
				isUpdatingFromStartPos = false;
			}
		});

		return () => unsubscribe();
	});

	// Listen for the custom event as an alternative way to receive updates
	onMount(() => {
		const handleStartPosSelectedEvent = (event: CustomEvent) => {
			if (event.detail?.startPosition) {
				// Set flag to prevent circular updates
				isUpdatingFromStartPos = true;

				try {
					// Create a deep copy to avoid reference issues
					const newStartPos = JSON.parse(JSON.stringify(event.detail.startPosition));

					// Update the pictograph data
					pictographData = safeCopyPictographData(newStartPos);

					// Also update the pictographContainer
					pictographContainer.setData(pictographData);

					// Save to localStorage directly to ensure it's available during hot reloads
					try {
						localStorage.setItem('start_position', JSON.stringify(pictographData));
					} catch (error) {
						console.error('Failed to save start position to localStorage:', error);
					}

					// Update the beat data
					beatData = {
						...beatData,
						pictographData: newStartPos,
						filled: true
					};
				} finally {
					// Reset flag after updates are complete
					isUpdatingFromStartPos = false;
				}
			}
		};

		// Add event listener
		document.addEventListener(
			'start-position-selected',
			handleStartPosSelectedEvent as EventListener
		);

		return () => {
			// Clean up event listener
			document.removeEventListener(
				'start-position-selected',
				handleStartPosSelectedEvent as EventListener
			);
		};
	});

	// Handle clicks at this level to prevent multiple event handlers
	function handleContainerClick(event: MouseEvent) {
		// Only handle clicks directly on the container, not on children
		if (event.target === event.currentTarget) {
			// Provide haptic feedback when selecting the start position beat
			if (typeof window !== 'undefined' && hapticFeedbackService.isAvailable()) {
				hapticFeedbackService.trigger('selection');
			}

			// Call the actual click handler
			props.onClick();

			// Update dev tools after click
		}
	}

	function handleMouseEnter() {
		showBorder = true;
	}

	function handleMouseLeave() {
		showBorder = false;
	}
</script>

<button
	class="start-pos-beat"
	class:selected={isSelected}
	onclick={handleContainerClick}
	onmouseenter={handleMouseEnter}
	onmouseleave={handleMouseLeave}
	type="button"
>
	<div class="pictograph-wrapper">
		<Beat beat={beatData} onClick={props.onClick} isStartPosition={true} />
		<StyledBorderOverlay {pictographData} isEnabled={showBorder || isSelected} />
	</div>
</button>

<style>
	.start-pos-beat {
		position: relative;
		width: 100%;
		height: 100%;
		display: flex;
		justify-content: center;
		align-items: center;
		border-radius: 8px;
		background-color: transparent;
		border: none;
		padding: 0; /* Remove default button padding */
		margin: 0; /* Remove any margin */
		box-sizing: border-box; /* Ensure padding is included in width/height */
		transition: all 0.2s ease;
	}

	/* Style for selected state */
	.start-pos-beat.selected {
		background-color: rgba(255, 204, 0, 0.1); /* Match the gold color used for regular beats */
		box-shadow:
			0 0 0 2px rgba(255, 204, 0, 0.7),
			0 0 10px 2px rgba(255, 204, 0, 0.3); /* Primary border and outer glow */
		transform: scale(1.02);
		transition: all 0.2s ease-out; /* Ensure smooth transition */
	}

	.pictograph-wrapper {
		position: relative;
		width: 100%;
		height: 100%;
		display: flex;
		justify-content: center;
		align-items: center;
	}
</style>
